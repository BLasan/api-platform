// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package handlers

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigDataApiType.
const (
	APIConfigDataApiTypeAsyncsse       APIConfigDataApiType = "async/sse"
	APIConfigDataApiTypeAsyncwebsocket APIConfigDataApiType = "async/websocket"
	APIConfigDataApiTypeAsyncwebsub    APIConfigDataApiType = "async/websub"
	APIConfigDataApiTypeHttprest       APIConfigDataApiType = "http/rest"
)

// Defines values for APIConfigurationKind.
const (
	APIConfigurationKindAsyncsse       APIConfigurationKind = "async/sse"
	APIConfigurationKindAsyncwebsocket APIConfigurationKind = "async/websocket"
	APIConfigurationKindAsyncwebsub    APIConfigurationKind = "async/websub"
	APIConfigurationKindHttprest       APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// Defines values for ServerProtocol.
const (
	Kafka     ServerProtocol = "kafka"
	Mqtt      ServerProtocol = "mqtt"
	Sse       ServerProtocol = "sse"
	Websocket ServerProtocol = "websocket"
	Websub    ServerProtocol = "websub"
)

// Defines values for WebhookAPIDataApiType.
const (
	Asyncsse       WebhookAPIDataApiType = "async/sse"
	Asyncwebsocket WebhookAPIDataApiType = "async/websocket"
	Asyncwebsub    WebhookAPIDataApiType = "async/websub"
	Httprest       WebhookAPIDataApiType = "http/rest"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// ApiType API type
	ApiType APIConfigDataApiType `json:"apiType"`

	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations"`

	// Upstream List of backend service URLs
	Upstream []Upstream `json:"upstream"`

	// Version Semantic version of the API
	Version string `json:"version"`
}

// APIConfigDataApiType API type
type APIConfigDataApiType string

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	// Data API configuration payload (REST or Async API variants)
	Data APIConfiguration_Data `json:"data"`

	// Kind API type
	Kind APIConfigurationKind `json:"kind"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version"`
}

// APIConfiguration_Data API configuration payload (REST or Async API variants)
type APIConfiguration_Data struct {
	union json.RawMessage
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty"`
	Message *string             `json:"message,omitempty"`
	Status  *string             `json:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty"`
		} `json:"metadata,omitempty"`
	} `json:"api,omitempty"`
	Status *string `json:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Status    *string             `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// Channel Channel (topic/event stream) definition for async APIs.
type Channel struct {
	// Bindings Protocol-specific channel bindings (arbitrary key/value structure).
	Bindings *map[string]interface{} `json:"bindings,omitempty"`

	// Description Human-readable description of the channel.
	Description *string `json:"description,omitempty"`

	// Parameters Path/channel parameters (keyed by parameter name).
	Parameters *map[string]struct {
		Description *string `json:"description,omitempty"`

		// Schema JSON Schema fragment for the parameter value.
		Schema *map[string]interface{} `json:"schema,omitempty"`
	} `json:"parameters,omitempty"`

	// Path Channel path or topic identifier relative to API context.
	Path string `json:"path"`

	// Publish Producer (send) operation definition.
	Publish *struct {
		// Message Event/message definition transported over a channel.
		Message *ChannelMessage `json:"message,omitempty"`
		Summary *string         `json:"summary,omitempty"`
	} `json:"publish,omitempty"`

	// Subscribe Consumer (receive) operation definition.
	Subscribe *struct {
		// Message Event/message definition transported over a channel.
		Message *ChannelMessage `json:"message,omitempty"`
		Summary *string         `json:"summary,omitempty"`
	} `json:"subscribe,omitempty"`
}

// ChannelMessage Event/message definition transported over a channel.
type ChannelMessage struct {
	// ContentType Content type of the payload.
	ContentType *string `json:"content_type,omitempty"`

	// Name Logical message name.
	Name string `json:"name"`

	// Payload JSON Schema representation of the message body.
	Payload map[string]interface{} `json:"payload"`

	// Summary Short description of the message.
	Summary *string `json:"summary,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message"`
	Status  string `json:"status"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path"`
}

// OperationMethod HTTP method
type OperationMethod string

// Server Server definition for async or WebSub APIs.
type Server struct {
	// Bindings Protocol-specific server bindings (arbitrary key/value structure).
	Bindings *map[string]interface{} `json:"bindings,omitempty"`

	// Description Human-readable description of this server.
	Description *string `json:"description,omitempty"`

	// Protocol Transport protocol used by the server.
	Protocol ServerProtocol `json:"protocol"`

	// ProtocolVersion Version of the selected protocol (if applicable).
	ProtocolVersion *string `json:"protocolVersion,omitempty"`

	// Security Security requirements for this server (each item maps scheme name to optional scopes array).
	Security *[]map[string][]string `json:"security,omitempty"`

	// Url Base URL or connection string for the server (variables may be denoted by {name}).
	Url string `json:"url"`

	// Variables Templated variables contained in the server URL.
	Variables *map[string]struct {
		// Default Default value for the variable.
		Default string `json:"default"`

		// Description Description of the variable.
		Description *string `json:"description,omitempty"`

		// Enum Allowed values.
		Enum *[]string `json:"enum,omitempty"`
	} `json:"variables,omitempty"`
}

// ServerProtocol Transport protocol used by the server.
type ServerProtocol string

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`
}

// WebhookAPIData defines model for WebhookAPIData.
type WebhookAPIData struct {
	// ApiType API type
	ApiType WebhookAPIDataApiType `json:"apiType"`

	// Channels List of operations - HTTP operations for REST APIs or event/topic operations for async APIs
	Channels []Channel `json:"channels"`

	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context"`

	// Name Human-readable API name (must be URL-friendly - only letters, numbers, spaces, hyphens, underscores, and dots allowed)
	Name string `json:"name"`

	// Servers List of backend service URLs (for REST APIs) or event hub URLs (for async APIs)
	Servers []Server `json:"servers"`

	// Version Semantic version of the API
	Version string `json:"version"`
}

// WebhookAPIDataApiType API type
type WebhookAPIDataApiType string

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// AsAPIConfigData returns the union data inside the APIConfiguration_Data as a APIConfigData
func (t APIConfiguration_Data) AsAPIConfigData() (APIConfigData, error) {
	var body APIConfigData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAPIConfigData overwrites any union data inside the APIConfiguration_Data as the provided APIConfigData
func (t *APIConfiguration_Data) FromAPIConfigData(v APIConfigData) error {
	v.ApiType = "http/rest"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAPIConfigData performs a merge with any union data inside the APIConfiguration_Data, using the provided APIConfigData
func (t *APIConfiguration_Data) MergeAPIConfigData(v APIConfigData) error {
	v.ApiType = "http/rest"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookAPIData returns the union data inside the APIConfiguration_Data as a WebhookAPIData
func (t APIConfiguration_Data) AsWebhookAPIData() (WebhookAPIData, error) {
	var body WebhookAPIData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookAPIData overwrites any union data inside the APIConfiguration_Data as the provided WebhookAPIData
func (t *APIConfiguration_Data) FromWebhookAPIData(v WebhookAPIData) error {
	v.ApiType = "async/sse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookAPIData performs a merge with any union data inside the APIConfiguration_Data, using the provided WebhookAPIData
func (t *APIConfiguration_Data) MergeWebhookAPIData(v WebhookAPIData) error {
	v.ApiType = "async/sse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t APIConfiguration_Data) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"apiType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t APIConfiguration_Data) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "async/sse":
		return t.AsWebhookAPIData()
	case "http/rest":
		return t.AsAPIConfigData()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t APIConfiguration_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *APIConfiguration_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{name}/{version})
	DeleteAPI(c *gin.Context, name string, version string)
	// Get API configuration by name and version
	// (GET /apis/{name}/{version})
	GetAPIByNameVersion(c *gin.Context, name string, version string)
	// Update an existing API configuration
	// (PUT /apis/{name}/{version})
	UpdateAPI(c *gin.Context, name string, version string)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, name, version)
}

// GetAPIByNameVersion operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByNameVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByNameVersion(c, name, version)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", c.Param("version"), &version, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, name, version)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:name/:version", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:name/:version", wrapper.GetAPIByNameVersion)
	router.PUT(options.BaseURL+"/apis/:name/:version", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"P/FOZdxGLeve3G7+PwAA//8wcz6IakUAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
